# -*- coding: utf-8 -*-
"""Stocks Watchlist

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fNO4IxUdMZv5L6p4qvXalPjrv_GUlW0O
"""

import streamlit as st
import pandas as pd
import numpy as np
from scipy.signal import argrelextrema
from datetime import datetime, timedelta
from nsepython import *
import warnings
warnings.filterwarnings('ignore')

# Page config
st.set_page_config(
    page_title="My Stock Dashboard",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Personal Watchlist - NSE symbols
WATCHLIST = {
    'RELIANCE': 'RELIANCE',
    'ADANI ENT': 'ADANIENT',
    'ADANI GREEN': 'ADANIGREEN',
    'ADANI ENERGY': 'ADANIENSOL',
    'ADANI PORTS': 'ADANIPORTS',
    'ICICI BANK': 'ICICIBANK',
    'HDFC BANK': 'HDFCBANK',
    'M&M': 'M&M',
    'MARUTI': 'MARUTI',
    'TATA MOTORS': 'TATAMOTORS',
    'HCL TECH': 'HCLTECH',
    'INFOSYS': 'INFY',
    'SUN PHARMA': 'SUNPHARMA',
}

# ============================================================================
# DATA FETCHING - Using nsepython for real-time NSE data
# ============================================================================
@st.cache_data(ttl=300)  # Cache for 5 minutes
def fetch_stock_data(symbol):
    """Fetch historical data from NSE using nsepython"""
    try:
        # Get historical data for last 30 days
        end_date = datetime.now()
        start_date = end_date - timedelta(days=30)
        
        # Fetch equity historical data
        data = equity_history(symbol, "EQ", start_date, end_date)
        
        if data is None or len(data) == 0:
            return None
        
        # Convert to DataFrame
        df = pd.DataFrame(data)
        
        # Check if required columns exist and rename them
        column_mapping = {
            'CH_TIMESTAMP': 'Date',
            'CH_TRADE_HIGH_PRICE': 'High',
            'CH_TRADE_LOW_PRICE': 'Low',
            'CH_OPENING_PRICE': 'Open',
            'CH_CLOSING_PRICE': 'Close',
            'CH_TOT_TRADED_QTY': 'Volume'
        }
        
        # Rename columns if they exist
        for old_col, new_col in column_mapping.items():
            if old_col in df.columns:
                df[new_col] = df[old_col]
        
        # Check if we have the required columns
        required_cols = ['Date', 'Open', 'High', 'Low', 'Close']
        if not all(col in df.columns for col in required_cols):
            st.warning(f"Missing required columns for {symbol}. Available: {df.columns.tolist()}")
            return None
        
        # Convert Date to datetime and set as index
        df['Date'] = pd.to_datetime(df['Date'])
        df = df.set_index('Date').sort_index()
        
        # Ensure index is DatetimeIndex
        if not isinstance(df.index, pd.DatetimeIndex):
            df.index = pd.to_datetime(df.index)
        
        # Select only required columns
        df = df[['Open', 'High', 'Low', 'Close']]
        
        # Resample to hourly for analysis (forward fill for missing hours)
        df_hourly = df.resample('1H').ffill().dropna()
        
        return df_hourly

    except Exception as e:
        st.error(f"Error fetching {symbol}: {e}")
        return None

@st.cache_data(ttl=60)  # Cache for 1 minute
def get_live_price(symbol):
    """Get current live price from NSE using nsepython"""
    try:
        quote = nse_eq(symbol)
        if quote and 'priceInfo' in quote:
            return quote['priceInfo']['lastPrice']
        return None
    except Exception as e:
        return None

def get_quote_data(symbol):
    """Get full quote including change, volume etc using nsepython"""
    try:
        quote = nse_eq(symbol)
        if not quote:
            return None

        price_info = quote.get('priceInfo', {})
        intraday = price_info.get('intraDayHighLow', {})

        return {
            'lastPrice': price_info.get('lastPrice', 0),
            'change': price_info.get('change', 0),
            'pChange': price_info.get('pChange', 0),
            'open': price_info.get('open', 0),
            'dayHigh': intraday.get('max', 0),
            'dayLow': intraday.get('min', 0),
            'previousClose': price_info.get('previousClose', 0),
        }
    except Exception as e:
        return None

# ============================================================================
# TECHNICAL INDICATORS
# ============================================================================
def calculate_rsi(data, period=14):
    """Calculate RSI indicator"""
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_williams_r(data, period=14):
    """Calculate Williams %R indicator"""
    highest_high = data['High'].rolling(window=period).max()
    lowest_low = data['Low'].rolling(window=period).min()
    williams_r = ((highest_high - data['Close']) / (highest_high - lowest_low)) * -100
    return williams_r

def find_peaks_troughs(data, order=3):
    """Find peaks and troughs in price and RSI"""
    price_peaks = argrelextrema(data['Close'].values, np.greater, order=order)[0]
    price_troughs = argrelextrema(data['Close'].values, np.less, order=order)[0]
    rsi_peaks = argrelextrema(data['RSI'].values, np.greater, order=order)[0]
    rsi_troughs = argrelextrema(data['RSI'].values, np.less, order=order)[0]
    return price_peaks, price_troughs, rsi_peaks, rsi_troughs

# ============================================================================
# RSI DIVERGENCE DETECTION
# ============================================================================
def calculate_divergence_strength(price_1, price_2, rsi_1, rsi_2, div_type):
    """Calculate strength of divergence signal"""
    score = 0

    # Price movement score
    price_change_pct = abs((price_2 - price_1) / price_1 * 100)
    if price_change_pct > 5:
        score += 30
    elif price_change_pct > 3:
        score += 20
    elif price_change_pct > 1:
        score += 10

    # RSI divergence score
    rsi_divergence = abs(rsi_2 - rsi_1)
    if rsi_divergence > 15:
        score += 30
    elif rsi_divergence > 10:
        score += 20
    elif rsi_divergence > 5:
        score += 10

    # Extreme zone bonus
    if div_type == 'Bullish':
        if rsi_2 < 30:
            score += 20
        elif rsi_2 < 40:
            score += 10
    else:
        if rsi_2 > 70:
            score += 20
        elif rsi_2 > 60:
            score += 10

    score += 20  # Base score
    return min(score, 100)

def detect_bullish_divergence(data, lookback=50):
    """Detect bullish RSI divergence"""
    price_peaks, price_troughs, rsi_peaks, rsi_troughs = find_peaks_troughs(data)
    divergences = []

    if len(price_troughs) >= 2 and len(rsi_troughs) >= 2:
        recent_price_troughs = [i for i in price_troughs if i >= max(0, len(data) - lookback)]
        recent_rsi_troughs = [i for i in rsi_troughs if i >= max(0, len(data) - lookback)]

        if len(recent_price_troughs) >= 2 and len(recent_rsi_troughs) >= 2:
            pt1, pt2 = recent_price_troughs[-2], recent_price_troughs[-1]
            rt1, rt2 = recent_rsi_troughs[-2], recent_rsi_troughs[-1]

            # Price making lower low, RSI making higher low = Bullish divergence
            if (data['Close'].iloc[pt2] < data['Close'].iloc[pt1] and
                data['RSI'].iloc[rt2] > data['RSI'].iloc[rt1]):

                strength = calculate_divergence_strength(
                    data['Close'].iloc[pt1], data['Close'].iloc[pt2],
                    data['RSI'].iloc[rt1], data['RSI'].iloc[rt2], 'Bullish'
                )

                divergences.append({'type': 'Bullish', 'strength': strength})

    return divergences

def detect_bearish_divergence(data, lookback=50):
    """Detect bearish RSI divergence"""
    price_peaks, price_troughs, rsi_peaks, rsi_troughs = find_peaks_troughs(data)
    divergences = []

    if len(price_peaks) >= 2 and len(rsi_peaks) >= 2:
        recent_price_peaks = [i for i in price_peaks if i >= max(0, len(data) - lookback)]
        recent_rsi_peaks = [i for i in rsi_peaks if i >= max(0, len(data) - lookback)]

        if len(recent_price_peaks) >= 2 and len(recent_rsi_peaks) >= 2:
            pp1, pp2 = recent_price_peaks[-2], recent_price_peaks[-1]
            rp1, rp2 = recent_rsi_peaks[-2], recent_rsi_peaks[-1]

            # Price making higher high, RSI making lower high = Bearish divergence
            if (data['Close'].iloc[pp2] > data['Close'].iloc[pp1] and
                data['RSI'].iloc[rp2] < data['RSI'].iloc[rp1]):

                strength = calculate_divergence_strength(
                    data['Close'].iloc[pp1], data['Close'].iloc[pp2],
                    data['RSI'].iloc[rp1], data['RSI'].iloc[rp2], 'Bearish'
                )

                divergences.append({'type': 'Bearish', 'strength': strength})

    return divergences

# ============================================================================
# STOCK ANALYSIS
# ============================================================================
def analyze_stock(symbol_name, symbol_code):
    """Complete technical analysis for a stock"""
    try:
        # Fetch historical data
        data = fetch_stock_data(symbol_code)

        # Get live quote
        quote = get_quote_data(symbol_code)

        if data is None or len(data) < 30:
            # If no historical data, just show live price
            if quote:
                return {
                    'symbol': symbol_name,
                    'price': quote['lastPrice'],
                    'price_change': quote['change'],
                    'price_change_pct': quote['pChange'],
                    'day_high': quote['dayHigh'],
                    'day_low': quote['dayLow'],
                    'rsi': None,
                    'rsi_signal': 'NO DATA',
                    'rsi_strength': 0,
                    'williams_r': None,
                    'wr_zone': 'NO DATA',
                    'wr_alert': False,
                    'data': None
                }
            return None

        # Calculate indicators
        data['RSI'] = calculate_rsi(data)
        data['WilliamsR'] = calculate_williams_r(data)
        data['PriceChange'] = data['Close'].pct_change() * 100
        data = data.dropna()

        if len(data) == 0:
            return None

        # Get current indicator values
        current_rsi = data['RSI'].iloc[-1]
        current_wr = data['WilliamsR'].iloc[-1]

        # Use live price if available, otherwise use last close
        current_price = quote['lastPrice'] if quote else data['Close'].iloc[-1]
        price_change = quote['change'] if quote else data['Close'].iloc[-1] - data['Close'].iloc[-2]
        price_change_pct = quote['pChange'] if quote else ((data['Close'].iloc[-1] / data['Close'].iloc[-2]) - 1) * 100

        # Detect RSI divergences
        bullish_div = detect_bullish_divergence(data)
        bearish_div = detect_bearish_divergence(data)

        # Determine RSI signal
        rsi_signal = "NEUTRAL"
        rsi_strength = 0
        if bullish_div:
            rsi_signal = "BULLISH"
            rsi_strength = max([d['strength'] for d in bullish_div])
        elif bearish_div:
            rsi_signal = "BEARISH"
            rsi_strength = max([d['strength'] for d in bearish_div])

        # Determine Williams %R zone
        wr_zone = "NEUTRAL"
        wr_alert = False
        if -5 <= current_wr <= 0:
            wr_zone = "EXTREME OVERBOUGHT"
            wr_alert = True
        elif -100 <= current_wr <= -95:
            wr_zone = "EXTREME OVERSOLD"
            wr_alert = True
        elif -20 <= current_wr < -5:
            wr_zone = "OVERBOUGHT"
        elif -95 < current_wr <= -80:
            wr_zone = "OVERSOLD"

        return {
            'symbol': symbol_name,
            'price': current_price,
            'price_change': price_change,
            'price_change_pct': price_change_pct,
            'day_high': quote['dayHigh'] if quote else data['High'].iloc[-1],
            'day_low': quote['dayLow'] if quote else data['Low'].iloc[-1],
            'rsi': current_rsi,
            'rsi_signal': rsi_signal,
            'rsi_strength': rsi_strength,
            'williams_r': current_wr,
            'wr_zone': wr_zone,
            'wr_alert': wr_alert,
            'data': data.tail(15)
        }

    except Exception as e:
        st.error(f"Error analyzing {symbol_name}: {str(e)}")
        return None

# ============================================================================
# HEATMAP GENERATION
# ============================================================================
def create_heatmap(results):
    """Generate HTML heatmap for technical indicators"""

    def get_rsi_color(val):
        if val < 30: return '#dc2626'
        elif val < 40: return '#f97316'
        elif val < 60: return '#22c55e'
        elif val < 70: return '#f97316'
        else: return '#dc2626'

    def get_wr_color(val):
        if val < -80: return '#dc2626'
        elif val < -60: return '#f97316'
        elif val < -40: return '#22c55e'
        elif val < -20: return '#f97316'
        else: return '#dc2626'

    def get_price_color(val):
        if val >= 1: return '#16a34a'
        elif val >= 0.5: return '#22c55e'
        elif val >= 0.2: return '#4ade80'
        elif val > -0.2: return '#6b7280'
        elif val > -0.5: return '#fb923c'
        elif val > -1: return '#f97316'
        else: return '#dc2626'

    # Filter results with data
    valid_results = [r for r in results if r.get('data') is not None]

    if not valid_results:
        return "<p>No data available for heatmap</p>"

    html = """
    <style>
        .heatmap-container {
            overflow-x: auto;
            margin: 20px 0;
        }
        .heatmap-table {
            border-collapse: collapse;
            font-size: 11px;
            width: 100%;
        }
        .heatmap-table th {
            background-color: #1e1e1e;
            color: white;
            padding: 8px 6px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 10;
            border: 1px solid #333;
        }
        .heatmap-table td {
            padding: 8px 6px;
            text-align: center;
            color: white;
            font-weight: bold;
            border: 1px solid #333;
            min-width: 50px;
        }
        .stock-label {
            position: sticky;
            left: 0;
            background-color: #2d2d2d;
            z-index: 5;
            font-weight: bold;
            text-align: left;
            padding-left: 12px !important;
            min-width: 140px;
        }
    </style>
    <div class="heatmap-container">
        <table class="heatmap-table">
            <thead>
                <tr>
                    <th class="stock-label">Stock / Indicator</th>
    """

    # Determine max length for headers
    max_len = max(len(r['data']) for r in valid_results)
    for i in range(max_len):
        html += f'<th>{max_len - i}h</th>'

    html += "</tr></thead><tbody>"

    # Generate rows for each stock
    for result in valid_results:
        data = result['data']
        symbol = result['symbol']

        rsi_vals = data['RSI'].tolist()
        wr_vals = data['WilliamsR'].tolist()
        prices = data['Close'].tolist()
        price_changes = data['PriceChange'].tolist()

        # Pad arrays to max length
        while len(rsi_vals) < max_len:
            rsi_vals = [None] + rsi_vals
            wr_vals = [None] + wr_vals
            prices = [None] + prices
            price_changes = [None] + price_changes

        # RSI Row
        html += f'<tr><td class="stock-label">{symbol} RSI</td>'
        for val in rsi_vals:
            if val is not None:
                color = get_rsi_color(val)
                html += f'<td style="background-color: {color}" title="RSI: {val:.1f}">{val:.0f}</td>'
            else:
                html += '<td style="background-color: #1e1e1e">-</td>'
        html += '</tr>'

        # Williams %R Row
        html += f'<tr><td class="stock-label">{symbol} W%R</td>'
        for val in wr_vals:
            if val is not None:
                color = get_wr_color(val)
                html += f'<td style="background-color: {color}" title="W%R: {val:.1f}">{val:.0f}</td>'
            else:
                html += '<td style="background-color: #1e1e1e">-</td>'
        html += '</tr>'

        # Price Row
        html += f'<tr><td class="stock-label">{symbol} Price</td>'
        for i in range(len(prices)):
            price = prices[i]
            change = price_changes[i]

            if price is not None and change is not None:
                color = get_price_color(change)
                sign = '+' if change > 0 else ''
                html += f'<td style="background-color: {color}" title="Price: ‚Çπ{price:.2f} | Change: {sign}{change:.2f}%">‚Çπ{price:.0f}<br><span style="font-size:9px">{sign}{change:.1f}%</span></td>'
            elif price is not None:
                html += f'<td style="background-color: #1e1e1e" title="Price: ‚Çπ{price:.2f}">‚Çπ{price:.0f}</td>'
            else:
                html += '<td style="background-color: #1e1e1e">-</td>'
        html += '</tr>'

    html += "</tbody></table></div>"
    return html

# ============================================================================
# MAIN DASHBOARD
# ============================================================================
def main():
    st.title("üìä My Personal Stock Dashboard")
    st.markdown(f"**Live NSE Data** | Last Updated: {datetime().strftime('%H:%M:%S')}")

    # Sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è Settings")

        auto_refresh = st.checkbox("Auto Refresh (60s)", value=False)

        if st.button("üîÑ Refresh Now", use_container_width=True):
            st.cache_data.clear()
            st.rerun()

        st.markdown("---")
        st.subheader("üìã My Watchlist")
        for name in WATCHLIST.keys():
            st.markdown(f"‚Ä¢ {name}")

        st.markdown("---")
        st.caption("üí° **Strategy:** Look for RSI divergence + Williams %R extreme zones")
        st.caption("üìä **Data:** Real-time from NSE India")

    # Auto refresh
    if auto_refresh:
        import time
        time.sleep(60)
        st.rerun()

    # Main tabs
    tab1, tab2, tab3 = st.tabs(["üìä Overview", "üéØ Signals", "üî• Heatmap"])

    # Analyze all stocks
    with st.spinner("üì° Fetching live data from NSE..."):
        results = []
        progress = st.progress(0)
        for idx, (name, code) in enumerate(WATCHLIST.items()):
            result = analyze_stock(name, code)
            if result:
                results.append(result)
            progress.progress((idx + 1) / len(WATCHLIST))
        progress.empty()

    # ========================================================================
    # TAB 1: OVERVIEW
    # ========================================================================
    with tab1:
        st.subheader("üìà Market Overview")

        # Summary metrics
        col1, col2, col3, col4 = st.columns(4)

        bullish_count = sum(1 for r in results if r.get('rsi_signal') == 'BULLISH')
        bearish_count = sum(1 for r in results if r.get('rsi_signal') == 'BEARISH')
        wr_alerts = sum(1 for r in results if r.get('wr_alert', False))

        col1.metric("üü¢ Bullish", bullish_count)
        col2.metric("üî¥ Bearish", bearish_count)
        col3.metric("‚ö° Alerts", wr_alerts)
        col4.metric("üìä Stocks", len(results))

        st.markdown("---")

        # Display each stock
        for result in results:
            with st.expander(f"**{result['symbol']}** - ‚Çπ{result['price']:.2f}", expanded=False):
                col1, col2, col3, col4 = st.columns(4)

                with col1:
                    st.metric(
                        "Live Price",
                        f"‚Çπ{result['price']:.2f}",
                        f"{result['price_change']:+.2f} ({result['price_change_pct']:+.2f}%)"
                    )
                    st.caption(f"High: ‚Çπ{result['day_high']:.2f} | Low: ‚Çπ{result['day_low']:.2f}")

                with col2:
                    if result['rsi'] is not None:
                        rsi_emoji = "üü¢" if result['rsi'] < 40 else "üî¥" if result['rsi'] > 60 else "‚ö™"
                        st.metric("RSI", f"{result['rsi']:.1f} {rsi_emoji}", result['rsi_signal'])
                        if result['rsi_signal'] not in ['NEUTRAL', 'NO DATA']:
                            st.caption(f"üí™ Strength: {result['rsi_strength']:.0f}/100")
                    else:
                        st.metric("RSI", "N/A", "NO DATA")

                with col3:
                    if result['williams_r'] is not None:
                        wr_emoji = "üî¥" if "OVERBOUGHT" in result['wr_zone'] else "üü¢" if "OVERSOLD" in result['wr_zone'] else "‚ö™"
                        st.metric("Williams %R", f"{result['williams_r']:.1f} {wr_emoji}", result['wr_zone'])
                    else:
                        st.metric("Williams %R", "N/A", "NO DATA")

                with col4:
                    if result['wr_alert']:
                        st.warning("‚ö†Ô∏è **EXTREME ZONE**")
                        st.caption("High reversal probability!")
                    elif result['rsi_signal'] == 'BULLISH':
                        st.success("üìà **BUY SIGNAL**")
                    elif result['rsi_signal'] == 'BEARISH':
                        st.error("üìâ **SELL SIGNAL**")
                    else:
                        st.info("üòê Neutral")

    # ========================================================================
    # TAB 2: SIGNALS
    # ========================================================================
    with tab2:
        st.subheader("üéØ Active Trading Signals")

        # Filter stocks with signals
        signal_results = [r for r in results if r.get('rsi_signal') not in ['NEUTRAL', 'NO DATA'] or r.get('wr_alert', False)]

        if not signal_results:
            st.info("üò¥ No active signals. Market is in neutral zone.")
        else:
            # RSI Signals
            st.markdown("### üìä RSI Divergence Signals")

            col1, col2 = st.columns(2)

            with col1:
                st.markdown("**üü¢ BULLISH DIVERGENCE**")
                bullish = [r for r in signal_results if r.get('rsi_signal') == 'BULLISH']
                if bullish:
                    bullish.sort(key=lambda x: x.get('rsi_strength', 0), reverse=True)
                    for stock in bullish:
                        st.success(f"**{stock['symbol']}** - ‚Çπ{stock['price']:.2f}")
                        st.caption(f"RSI: {stock['rsi']:.1f} | Strength: {stock['rsi_strength']:.0f}/100")
                else:
                    st.info("No bullish signals")

            with col2:
                st.markdown("**üî¥ BEARISH DIVERGENCE**")
                bearish = [r for r in signal_results if r.get('rsi_signal') == 'BEARISH']
                if bearish:
                    bearish.sort(key=lambda x: x.get('rsi_strength', 0), reverse=True)
                    for stock in bearish:
                        st.error(f"**{stock['symbol']}** - ‚Çπ{stock['price']:.2f}")
                        st.caption(f"RSI: {stock['rsi']:.1f} | Strength: {stock['rsi_strength']:.0f}/100")
                else:
                    st.info("No bearish signals")

            st.markdown("---")

            # Williams %R Alerts
            st.markdown("### ‚ö° Williams %R Extreme Zones")

            wr_stocks = [r for r in signal_results if r.get('wr_alert', False)]
            if wr_stocks:
                col1, col2 = st.columns(2)

                with col1:
                    st.markdown("**üî¥ EXTREME OVERBOUGHT**")
                    ob = [r for r in wr_stocks if "OVERBOUGHT" in r.get('wr_zone', '')]
                    if ob:
                        for stock in ob:
                            st.warning(f"**{stock['symbol']}** - ‚Çπ{stock['price']:.2f}")
                            st.caption(f"W%R: {stock['williams_r']:.1f}")
                    else:
                        st.info("None")

                with col2:
                    st.markdown("**üü¢ EXTREME OVERSOLD**")
                    os = [r for r in wr_stocks if "OVERSOLD" in r.get('wr_zone', '')]
                    if os:
                        for stock in os:
                            st.warning(f"**{stock['symbol']}** - ‚Çπ{stock['price']:.2f}")
                            st.caption(f"W%R: {stock['williams_r']:.1f}")
                    else:
                        st.info("None")
            else:
                st.info("No extreme zones detected")

    # ========================================================================
    # TAB 3: HEATMAP
    # ========================================================================
    with tab3:
        st.subheader("üî• Technical Indicators Heatmap")
        st.markdown("**15-hour view: RSI, Williams %R, and Price movements**")

        heatmap_html = create_heatmap(results)
        st.markdown(heatmap_html, unsafe_allow_html=True)

        st.markdown("---")
        col1, col2, col3 = st.columns(3)

        with col1:
            st.markdown("""
            **RSI Colors:**
            - üü¢ 40-60: Neutral
            - üü† 30-40, 60-70: Caution
            - üî¥ <30, >70: Extreme
            """)

        with col2:
            st.markdown("""
            **Williams %R:**
            - üü¢ -60 to -40: Neutral
            - üü† -80 to -60, -40 to -20: Caution
            - üî¥ <-80, >-20: Extreme
            """)

        with col3:
            st.markdown("""
            **Price Change:**
            - üü¢ Positive
            - ‚ö™ Flat
            - üî¥ Negative
            """)

if __name__ == "__main__":
    main()
